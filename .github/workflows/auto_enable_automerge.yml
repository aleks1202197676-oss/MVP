name: auto-enable-automerge

on:
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch:

permissions:
  pull-requests: write
  contents: write

concurrency:
  group: automerge-daemon
  cancel-in-progress: false

jobs:
  enable-automerge:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-enable PR automerge (0-click)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner;
            const name = context.repo.repo;
            const schedule = '*/5 * * * * (every 5 minutes)';
            const summaryPath = process.env.GITHUB_STEP_SUMMARY;

            const descriptionLines = [
              'PR-A8 automerge daemon:',
              '- Trigger: schedule + workflow_dispatch only.',
              `- Schedule interval: ${schedule}.`,
              '- Scope: open PRs targeting main.',
              '- Opt-in naming: title starts with "PR-" OR branch starts with "pr-" OR "codex/".',
              '- Opt-out naming: use titles/branches outside those prefixes.',
              '- Draft PRs and DIRTY/BLOCKED PRs are skipped.',
              '- Any API/GraphQL error (including unstable status) is logged and skipped; workflow remains successful.'
            ];

            core.info(descriptionLines.join('\n'));

            let scanned = 0;
            let eligible = 0;
            let enabled = 0;
            let skipped = 0;
            let warnings = 0;

            const writeSummary = () => {
              if (!summaryPath) {
                core.warning('GITHUB_STEP_SUMMARY is not available.');
                return;
              }

              const summaryLines = [
                '## 0-click automerge daemon',
                ...descriptionLines,
                '',
                `Scanned: ${scanned}`,
                `Eligible: ${eligible}`,
                `Enabled: ${enabled}`,
                `Skipped: ${skipped}`,
                `Warnings: ${warnings}`,
                '',
                'Opt-in reminder: PR title starts with "PR-" OR branch starts with "pr-" OR "codex/".',
                ''
              ];

              fs.appendFileSync(summaryPath, `${summaryLines.join('\n')}\n`);
            };

            const query = `
              query($owner: String!, $name: String!, $cursor: String) {
                repository(owner: $owner, name: $name) {
                  pullRequests(first: 100, after: $cursor, states: OPEN, baseRefName: "main", orderBy: {field: CREATED_AT, direction: ASC}) {
                    nodes {
                      id
                      number
                      title
                      isDraft
                      headRefName
                      mergeStateStatus
                    }
                    pageInfo {
                      hasNextPage
                      endCursor
                    }
                  }
                }
              }
            `;

            const mutation = `
              mutation($pullRequestId: ID!) {
                enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: SQUASH }) {
                  pullRequest {
                    number
                    autoMergeRequest {
                      enabledAt
                    }
                  }
                }
              }
            `;

            try {
              const allPrs = [];
              let cursor = null;

              try {
                while (true) {
                  const data = await github.graphql(query, { owner, name, cursor });
                  const pullRequests = data.repository.pullRequests;
                  allPrs.push(...pullRequests.nodes);
                  if (!pullRequests.pageInfo.hasNextPage) break;
                  cursor = pullRequests.pageInfo.endCursor;
                }
              } catch (error) {
                const message = (error && error.message) ? error.message : String(error);
                warnings += 1;
                core.warning(`Repository PR scan failed: ${message}`);
                return;
              }

              scanned = allPrs.length;
              core.info(`Found ${scanned} open PR(s) targeting main.`);

              for (const pr of allPrs) {
                try {
                  const optIn = pr.title.startsWith('PR-') || pr.headRefName.startsWith('pr-') || pr.headRefName.startsWith('codex/');

                  if (pr.isDraft) {
                    skipped += 1;
                    core.info(`#${pr.number} skipped: draft PR.`);
                    continue;
                  }

                  if (!optIn) {
                    skipped += 1;
                    core.info(`#${pr.number} skipped: does not match opt-in naming.`);
                    continue;
                  }

                  if (pr.mergeStateStatus === 'DIRTY' || pr.mergeStateStatus === 'BLOCKED') {
                    skipped += 1;
                    core.info(`#${pr.number} skipped: mergeStateStatus=${pr.mergeStateStatus}.`);
                    continue;
                  }

                  eligible += 1;

                  try {
                    await github.graphql(mutation, { pullRequestId: pr.id });
                    enabled += 1;
                    core.info(`#${pr.number} auto-merge enabled (SQUASH).`);
                  } catch (error) {
                    warnings += 1;
                    skipped += 1;
                    const message = (error && error.message) ? error.message : String(error);
                    core.warning(`#${pr.number} skipped: enablePullRequestAutoMerge error: ${message}`);
                  }
                } catch (error) {
                  warnings += 1;
                  skipped += 1;
                  const message = (error && error.message) ? error.message : String(error);
                  core.warning(`#${pr.number} skipped: unexpected processing error: ${message}`);
                }
              }
            } catch (error) {
              warnings += 1;
              const message = (error && error.message) ? error.message : String(error);
              core.warning(`Automerge daemon handled fatal error and continued: ${message}`);
            } finally {
              try {
                writeSummary();
              } catch (error) {
                const message = (error && error.message) ? error.message : String(error);
                core.warning(`Failed to write step summary: ${message}`);
              }
            }
