name: Auto Update PR Branches

on:
  schedule:
    - cron: '*/10 * * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: pr-branch-updater
  cancel-in-progress: false

jobs:
  auto-update:
    runs-on: ubuntu-latest
    steps:
      - name: Update eligible PR branches behind main
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const counts = {
              scanned: 0,
              eligible: 0,
              behind: 0,
              updated: 0,
              skippedDirty: 0,
              skippedBlocked: 0,
              skippedDraft: 0,
              skippedNotOptIn: 0,
              warnings: 0,
            };

            const warnings = [];

            const addWarning = (message) => {
              counts.warnings += 1;
              warnings.push(message);
              core.warning(message);
            };

            const isOptIn = (pr) => {
              return (
                pr.title.startsWith('PR-') ||
                pr.headRefName.startsWith('pr-') ||
                pr.headRefName.startsWith('codex/')
              );
            };

            const query = `
              query($owner: String!, $repo: String!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequests(
                    states: OPEN
                    baseRefName: \"main\"
                    first: 100
                    after: $after
                    orderBy: { field: CREATED_AT, direction: DESC }
                  ) {
                    pageInfo {
                      hasNextPage
                      endCursor
                    }
                    nodes {
                      number
                      title
                      isDraft
                      headRefName
                      mergeStateStatus
                    }
                  }
                }
              }
            `;

            try {
              let after = null;
              let hasNextPage = true;

              while (hasNextPage) {
                let prNodes = [];
                try {
                  const result = await github.graphql(query, { owner, repo, after });
                  const pullRequests = result?.repository?.pullRequests;
                  prNodes = pullRequests?.nodes || [];
                  hasNextPage = Boolean(pullRequests?.pageInfo?.hasNextPage);
                  after = pullRequests?.pageInfo?.endCursor || null;
                } catch (error) {
                  addWarning(`GraphQL list error: ${error.message}`);
                  break;
                }

                for (const pr of prNodes) {
                  counts.scanned += 1;

                  if (pr.isDraft) {
                    counts.skippedDraft += 1;
                    continue;
                  }

                  if (!isOptIn(pr)) {
                    counts.skippedNotOptIn += 1;
                    continue;
                  }

                  counts.eligible += 1;

                  if (pr.mergeStateStatus === 'BEHIND') {
                    counts.behind += 1;
                    try {
                      await github.rest.pulls.updateBranch({
                        owner,
                        repo,
                        pull_number: pr.number,
                      });
                      counts.updated += 1;
                    } catch (error) {
                      addWarning(`PR #${pr.number} update error: ${error.message}`);
                    }
                    continue;
                  }

                  if (pr.mergeStateStatus === 'DIRTY') {
                    counts.skippedDirty += 1;
                    continue;
                  }

                  if (pr.mergeStateStatus === 'BLOCKED') {
                    counts.skippedBlocked += 1;
                    continue;
                  }
                }
              }
            } catch (error) {
              addWarning(`Unexpected workflow script error: ${error.message}`);
            }

            const skippedTotal =
              counts.skippedDirty +
              counts.skippedBlocked +
              counts.skippedDraft +
              counts.skippedNotOptIn;

            try {
              await core.summary
                .addHeading('Auto-update PR branches summary')
                .addTable([
                  [{ data: 'Metric', header: true }, { data: 'Count', header: true }],
                  ['scanned', String(counts.scanned)],
                  ['eligible', String(counts.eligible)],
                  ['behind', String(counts.behind)],
                  ['updated', String(counts.updated)],
                  [
                    'skipped (dirty/blocked/draft/not-optin)',
                    `${skippedTotal} (${counts.skippedDirty}/${counts.skippedBlocked}/${counts.skippedDraft}/${counts.skippedNotOptIn})`,
                  ],
                  ['warnings', String(counts.warnings)],
                ])
                .addRaw(`\nSchedule: every 10 minutes (cron: */10 * * * *)\n`)
                .write();
            } catch (error) {
              addWarning(`Step summary error: ${error.message}`);
            }

            if (warnings.length > 0) {
              core.info(`Completed with ${warnings.length} warning(s).`);
            }
